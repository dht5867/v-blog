[{"title":"freemarker动态生成插入图片的Word文档","url":"/2019/07/04/freemarker动态生成插入图片的Word文档/"},{"title":"过滤器、拦截器、监听器区别","url":"/2019/07/04/过滤器、拦截器、监听器区别/","content":"1.过滤器\n\nServlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。\n其工作原理是，只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可进行逻辑判断，如用户是否已经登陆、有没有权限访问该页面等等工作。\n它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关请求，只有当你的web应用停止或重新部署的时候才销毁。\n \n```\n \n MyCharsetFilter.java 编码过滤器 \n \n// 主要目的：过滤字符编码；其次，做一些应用逻辑判断等. \n// Filter跟web应用一起启动 \n// 当web应用重新启动或销毁时，Filter也被销毁 \npublic class MyCharsetFilter implements Filter { \n     private FilterConfig config = null; \n     public void destroy() { \n         System.out.println(\"MyCharsetFilter准备销毁...\"); \n     } \n  \n     public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain chain) throws IOException, ServletException { \n         // 强制类型转换 \n         HttpServletRequest request = (HttpServletRequest)arg0; \n         HttpServletResponse response = (HttpServletResponse)arg1; \n         // 获取web.xm设置的编码集，设置到Request、Response中         \n　　　　  //request.setCharacterEncoding(config.getInitParameter(\"charset\"));          \n　　　　  //response.setContentType(config.getInitParameter(\"contentType\"));        \n 　　　　 //response.setCharacterEncoding(config.getInitParameter(\"charset\"));          \n        // 将请求转发到目的地 \n         chain.doFilter(request, response); \n     } \n  \n     public void init(FilterConfig arg0) throws ServletException { \n         this.config = arg0; \n         System.out.println(\"MyCharsetFilter初始化...\"); \n     } \n } \n ```\n以下是 MyCharsetFilter.Java 在web.xml 中配置:\n```\n <filter> \n       <filter-name>filter</filter-name> \n       <filter-class>dc.gz.filters.MyCharsetFilter</filter-class> \n       <init-param> \n           <param-name>charset</param-name> \n           <param-value>UTF-8</param-value> \n       </init-param> \n       <init-param> \n           <param-name>contentType</param-name> \n           <param-value>text/html;charset=UTF-8</param-value> \n       </init-param> \n   </filter> \n   <filter-mapping> \n       <filter-name>filter</filter-name> \n       <!-- * 代表截获所有的请求  或指定请求/test.do  /xxx.do --> \n       <url-pattern>/*</url-pattern> \n   </filter-mapping> \n```\n \n\n2.监听器\n\n现在来说说Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。\n主要作用是： 做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。他会对特定的事件产生一个处理。监听在很多模式下用到。比如说观察者模式，就是一个监听来的。又比如struts2 可 以用监听来启动。\nServlet监听器用于监听一些重要事件的发生，监听器对象可以在事情发生前、发生后可以做一些必要的处理。好比如果说Servlet 的监听器Listene。\n在web.xml中配置。\n```\nMyServletContextListener.java \n package dc.gz.listeners; \n import javax.servlet.ServletContext; \n import javax.servlet.ServletContextEvent; \n import javax.servlet.ServletContextListener; \n import org.apache.commons.dbcp.BasicDataSource; \n  \n  /** \n  * Web应用监听器 \n  */ \n public class MyServletContextListener implements ServletContextListener {   \n     // 应用监听器的销毁方法 \n     public void contextDestroyed(ServletContextEvent event) { \n         ServletContext sc = event.getServletContext(); \n         // 在整个web应用销毁之前调用，将所有应用空间所设置的内容清空 \n         sc.removeAttribute(\"dataSource\"); \n        System.out.println(\"销毁工作完成...\"); \n     } \n  \n     // 应用监听器的初始化方法 \n     public void contextInitialized(ServletContextEvent event) { \n         // 通过这个事件可以获取整个应用的空间 \n         // 在整个web应用下面启动的时候做一些初始化的内容添加工作 \n         ServletContext sc = event.getServletContext(); \n         // 设置一些基本的内容；比如一些参数或者是一些固定的对象 \n         // 创建DataSource对象，连接池技术 dbcp \n         BasicDataSource bds = new BasicDataSource(); \n         bds.setDriverClassName(\"com.mysql.jdbc.Driver\");                      \n         bds.setUrl(\"jdbc:mysql://localhost:3306/hibernate\"); \n         bds.setUsername(\"root\"); \n         bds.setPassword(\"root\"); \n         bds.setMaxActive(10);//最大连接数 \n         bds.setMaxIdle(5);//最大管理数 \n         //bds.setMaxWait(maxWait); 最大等待时间 \n         // 把 DataSource 放入ServletContext空间中， \n         // 供整个web应用的使用(获取数据库连接) \n         sc.setAttribute(\"dataSource\", bds); \n         System.out.println(\"应用监听器初始化工作完成...\"); \n         System.out.println(\"已经创建DataSource...\"); \n     } \n } \n```\n \n```\nweb.xml中配置如下，很简单：\n\n <!-- 配置应用监听器  --> \n   <listener> \n       <listener-class>dc.gz.listeners.MyServletContextListener</listener-class> \n   </listener> \n \n```\n \n\n3.拦截器\n\n拦截器是在面向切面编程中应用的，就是在你的service或者一个方法前调用一个方法，或者在方法后调用。是基于JAVA的反射机制。\n \n ```\n\n PermissionInterceptor权限控制类\npublic class PermissionInterceptor extends MethodFilterInterceptor {\n\n    private static final long serialVersionUID = -5360035516489852006L;\n\n    /**拦截每一个action请求\n     * @see com.opensymphony.xwork2.interceptor.MethodFilterInterceptor#doIntercept(com.opensymphony.xwork2.ActionInvocation)\n     */\n    @Override\n    protected String doIntercept(ActionInvocation invocation) throws Exception {\n\n        System.out.println(\"进入MyMethodInterceptor方法权限拦截器!!!!!!!!!!!!!\");\n\n        // 获取当前action的类\n        // final Class objClass=invocation.getAction().getClass();\n\n        // 获取当前用户session\n        Map<String, Object> session = invocation.getInvocationContext().getSession();\n\n        // 从session获取用户等信息\n        // User user = (User) session.get(\"login_\");\n        // String name=user.getUName();\n        // 判断当前用户权限，是否可以操作，struts.xml配置的方法，如果有权限就通过\n        //(Integer) ServletActionContext.getRequest().getSession().getAttribute(\"UAuth\")==1\n         if (Util.isHavePermission()) {\n            System.out.println(\"有权限，并且请求成功\");\n            // 表示通过验证，可以执行该action\n            return invocation.invoke();\n        }\n        // Object actionObj=objClass.newInstance();\n        // objClass.getDeclaredField(\"opMsg\").set(actionObj,\n        // \"对不起，您的权限不够，无法进行该操作！\");\n        // objClass.getDeclaredMethod(\"setOpMsg\",\n        // String.class).invoke(actionObj, \"对不起，您的权限不够，无法进行该操作！\");\n        invocation.getInvocationContext().put(\"msg\", \"对不起，您的权限不够，无法进行该操作！\");\n        session.put(\"msg\", \"对不起，您的权限不够，无法进行该操作！\");\n        System.out.println(\"权限不够被拒绝\");\n        return \"error\";\n    }\n\n}\n ```\n\nstruts2配置文件：\n\n```\n<!--</package> -->\n    <!-- 定义包，名字basePackage，继承struts默认包 -->\n    <package name=\"basePackage\" extends=\"struts-default\">\n        <!--struts 拦截器实现 -->\n        <interceptors>\n            <!-- 配置权限拦截器 -->\n            <interceptor name=\"permission\"\n                class=\"com.xx.interceptor.PermissionInterceptor\">\n                <!-- 需要拦截的方法 -->\n                <!-- execludeMethods：该参数指定拦截器拒绝拦截的方法列表，多个方法用“，”隔开（支持通配符*，例如add*，表示所有以add开头的方法），\n                 如果指定了这个参数拦截器不会拦截指定列表中的方法，就是所谓的黑名单 \n                    includeMethods： 该参数指定拦截器需要拦截的方法列表，多个方法用“，”隔开（支持通配符*，例如add*，表示所有以add开头的方法），\n                 如果指定了参数，则指定的Action在执行前会被拦截，即白名单。 -->\n                <param name=\"includeMethods\">deleteUser,deleteAccount,deleteRecord</param>\n                <!-- 不需要拦截的方法 -->\n                <param name=\"excludeMethods\">query*</param>\n            </interceptor>\n\n            <!-- 定义拦截器栈 -->\n            <interceptor-stack name=\"permissionStack\">\n                <interceptor-ref name=\"permission\" />\n                <interceptor-ref name=\"defaultStack\" />\n            </interceptor-stack>\n        </interceptors>\n        <!-- 定义默认拦截器 -->\n        <default-interceptor-ref name=\"permissionStack\"></default-interceptor-ref>\n    </package>\n```\n \n\n \n\n4.下面再详谈过滤器、拦截器的区别：\n\n1、拦截器是基于java反射机制的，而过滤器是基于函数回调的。\n\n2、过滤器依赖于servlet容器，而拦截器不依赖于servlet容器。\n\n3、拦截器只能对Action请求起作用，而过滤器则可以对几乎所有请求起作用。\n\n4、拦截器可以访问Action上下文、值栈里的对象，而过滤器不能。\n5、在Action的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。\n\n6、过滤器：取你需要的东西，忽视那些不需要的东西！在程序中，你希望选择中一篇文章中的所有数字，你就可以针对性的挑选数字！\n\n7、拦截器：针对你不要的东西进行拦截，比如说，在一个BBS里面你希望人家不要留“小乌鸦”的这个词，那你就可能采用拦截器!\n\n8、过滤器，是在Java web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts2的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts2的action前统一设置字符集，或者去除掉一些非法字符\n\n9、拦截器，是在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。\n\n10、执行顺序 ：过滤前 - 拦截前 - Action处理 - 拦截后 -过滤后。个人认为过滤是一个横向的过程，首先把客户端提交的内容进行过滤(例如未登录用户不能访问内部页面的处理)；过滤通过后，拦截器将检查用户提交数据的验证，做一些前期的数据处理，接着把处理后的数据发给对应的Action；Action处理完成返回后，拦截器还可以做其他过程，再向上返回到过滤器的后续操作。"},{"title":"linux常用指令","url":"/2019/07/04/linux常用指令/","content":"\n\n\n## 一、Linux目录\n/系统根目录\n/bin 二进制文件目录\n/etc 系统配置文件，不建议在次目录存放可执行文件，防火墙文件、网络设置文件、jdk环境，mysqlpeiz wenj \n/usr 应用程序存放文件， jdk,mysql ,redis\n/root 系统管理员root家目录 ，相当于Windows的桌面家目录，每个用户都有一个家目录\n## 二、磁盘管理命令\nls 列出目录内容\n参数 -a 列出所有包括隐藏文件 -l 列出详情 -h友好显示\n文件格式\ndrwxr-xr-x.  3 root root   4096 5月  22 2016 abrt\n-rw-r--r--.  1 root root     44 1月   9 13:47 adjtime\n-rw-r--r--.  1 root root   1512 1月  12 2010 aliases\n10位 drwxr-xr-x \nr 读 w 写 x 可以执行\nd 代表目录\n- 代表普通文件\nl 代表连接\n\ncd  change diroctory 切换目录\n 相对路径 绝对路径\ncd / \ncd ~ \ncd /root 切换到根目录的root 目录\n\npwd 显示当前所在目录\nmkdir （make dir） 创建目录\nmkdir  study\nrmdir  （remove dir） 删除空目录\nrmdir study\n\n## 三、文件浏览命令\n\n打开查看 日志文件 xml文件 pro 文件\n\ncat 小文件\n\nmore 大文件 ，enter下一行，空格下一页 q退出\n\nless 大文件查看分页显示\n-m 百分比\n-N 行号\nless -mN 文件名\n\ntail\ntail - 数子 文件名 快速查看文件后多少行的内容\ntail -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测\n\n## 四、文件操作命令\n\n1、文件复制 copy\n\ncp 复制文件或目录\n复制文件 cp post-install Documents\n复制文件夹  -r 表示级联复制 cp -r study Documents/ \n\n2、文件移动 mv（move）\n mv  文件/目录 移动的位置\n mv -f 文件覆盖  mv -f t5 t3\n mv 改名 mv mv dht.txt dd.txt\n\n3、文件删除 rm (rmove)\n-f(force)\n-r （reference）级联\n删除文件 rm -f 文件名  rm -f dd.txt\n删除目录 rm -rf 目录名  rm -rf study\n注意 \nrm -rf * 删除当前目录所有内容\nrm -rf /*  删除Linux 系统根目录下的所有内容\n\n\n4、查找命令 find 查找文件或目录\nfind find /root -name 'post*' 查找 以、a\\post字符开头的文件或目录\n结果\n/root/Documents/post-install\n/root/post-install.log\n/root/post-install\n\n5、文件编辑 vim \nvim 文件名进入一般模式 ，可以浏览 复制\n按i 进入插入模式 ，可以编辑删除\n按esc 退出到一般模式\n在一般模式输入：wq退出保存，按q!强制退出不保存\n\n## 管道命令 | 可以连接多个命令\n\ngrep 正则表达式 ，字符串搜索\n\ngrep 需要搜索的字符串 搜索的文件 复合返回当前行\n\n管道和grep集合\nll| grep dd\n-i（ignore）忽略大小写\ngrep - i dd \n\n\n## 压缩解压 tar\n\n格式 *.tar 多个文件打包为一个文件，大小不会进行压缩\n\t*.tar.gz 打包并压缩（gzip） \n\n1、压缩\ntar -zcvf \nz 使用gzip压缩\nc  建立一个压缩文件\nx 解压\nv 压缩的过程显示文件\nf 使用文档名\n\n2、解压\ntar zxvf redis-4.0.2.tar  解压到当前目录\ntar -zxvf 压缩包 —C  解压到指定目录\n\n## 系统命令\nps (process status)查看进程\nps -ef 查看系统进程\nuid 那个用户打开属于那个用户\npid 进程ID标识进程\ncmd 表明进程对应的程序，程序的位置\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 12:37 ?        00:00:01 /sbin/init\nroot         2     0  0 12:37 ?        00:00:00 [kthreadd]\nroot         3     2  0 12:37 ?        00:00:00 [migration/0]\nroot         4     2  0 12:37 ?        00:00:00 [ksoftirqd/0]\nroot       \n\nps -ef |grep -i vim\n\nps au| grep 端口、进程名\n\n## kill 干掉进程\nkill - 9 pid \n\nifconfig 网络配置\n\nping 网络连通命令测试\n\nnestat -nap \n\nhalt 直接关机\nreboot 重启\nsetup 网络配置\n\n## 权限授权命令 \nchmod(change mode)变更文件或目录权限\ndrwxr-xr-x. 2 root root  4096 1月  10 12:33 Desktop\ndrwxr-xr-x. 2 root root  4096 1月  10 13:29 Destop\ndrwxr-xr-x. 2 root root  4096 1月  10 13\n第一位：文件类型 d目录 -文件 l 链接\n2-4 位： 所属用户权限 u表示\n5-7位：所属组权限 g表示\n8-10 其他用户权限 o表示\n2-10 所有权限 a表示\nr -read 读\nw write 写\nx excute 执行\n- 没有权限\n\nchmod 权限设置 需要更改权限的文件名\nchmod u=rw- study\nchmod g=rwx study\n chmod a=rwx study\n改变study文件夹和文件夹下的权限\nchmod -R u=rw- study\n\nr=4,w=2,x=1\nrwxrwxrwx  777\nchmod 777 文件路径和名\n\n\n## 安装命令 \n\nrpm 想当于Windows的安装，添加卸载\nrpm -ivh 程序名安装\nrpm -qa 查看所有程序\nrpm -e --nodeps 程序名 程序卸载\n\nyum：相当于可以联网的rpm命令,先下载程序的安装包，在执行rpm安装命令\n-y 下载依赖安装\nyum -y install gcc gcc-c++ autoconf automake\n\nwget  联网下载安装\n-p 级联创建\nwget -P /usr/local http://nginx.org/download/nginx-1.12.2.tar.gz\n\n防火墙\n\n\n## shell脚本 \n\n\n```\n#！告诉系统其后路径所指定的程序，就是解释次脚本文件的shell 程序\n#! /bash/shell\necho \"hello world\"\n```\n赋予脚本执行权限\nchmod +x ./test.sh  #使脚本具有执行权限\n./test.sh  #执行脚本\n\n直接写test.sh执行过程linux系统会去path里寻找有没有test.sh的，而path路径里只有\n/bin,/sbin,/usr/bin,/usr/sbin,你的当前目录并不在path里，所以写成test.sh是不会找到命令的，需要./test.sh\n告诉系统在当前目录找\n\n定义shell变量， \nyour_name=\"runoob.com\"，但是变量名和等号之间不能有空格，不能使用bash关键字\n\n意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\n命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n中间不能有空格，可以使用下划线（_）。\n不能使用标点符号。\n不能使用bash里的关键字（可用help命令查看保留关键字）。\n\n\n## 常用例子\n解压文件\ntar zxvf redis-4.0.2.tar\n\n移动文件\nmv redis-4.0.2  /usr/local/\n\n创建文件\nmkdir  /usr/local/redis-4.0.2/bin\n复制文件\ncp /usr/local/redis-4.0.2/redis.conf /usr/local/redis-4.0.2/etc\n\n查看日志文件\ntail -f 文件名\n\nnatapp\n\n/Users/ximoyiren/soft/natapp\n\n\n查看端口占用\n\nnetstat -tunlp|grep 13200\n\nlsof -i:13200\n \n查看java进程\nps -ef | grep java\n\nps -ef | grep wecourt-worklog.jar\n\n查看Tomcat进程\n\nps -ef | grep tomcat6_js13200\n\n找到pid 在kill\n","tags":["--linux"]},{"title":"shardingjdbc分库分表","url":"/2019/07/04/sharding-jdbc分库分表/","content":"\n## 理论基础\n  数据切分根据其切分类型，可以分为两种方式\n- 垂直（纵向）切分：垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。\n\n- 水平（横向）切分：水平切分分为库内分表和分库分表，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。\n\n### 垂直分表\n垂直分表是基于数据库中的\"列\"进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。在字段很多的情况下（例如一个大表有100多个字段），通过\"大表拆小表\"，更便于开发与维护，也能避免跨页问题，MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销\n\n \n垂直切分优点：\n解决业务系统层面的耦合，业务清晰；\n与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等；\n高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈。\n缺点：\n部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度；\n分布式事务处理复杂；\n依然存在单表数据量过大的问题（需要水平切分）\n\n### 水平切分\n水平切分后同一张表会出现在多个数据库/表中，每个库/表的内容不同，一般按照时间区间或ID区间来切分。\n\n### 分库分表带来的问题\n  事务一致性问题\n  分布式事务\n  最终一致性\n  跨节点关联查询 join 问题\n  跨节点分页、排序、函数问题\n  全局主键避重问题\n  数据迁移、扩容问题\n\n## 实践\n\n### MySQL脚本\n```\ntest_msg1 数据库1\n-- ----------------------------\n-- Table structure for t_order_0\n-- ----------------------------\nDROP TABLE IF EXISTS `t_order_0`;\nCREATE TABLE `t_order_0` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n  `order_id` varchar(32) DEFAULT NULL COMMENT '顺序编号',\n  `user_id` varchar(32) DEFAULT NULL COMMENT '用户编号',\n  `userName` varchar(32) DEFAULT NULL COMMENT '用户名',\n  `passWord` varchar(32) DEFAULT NULL COMMENT '密码',\n  `user_sex` varchar(32) DEFAULT NULL,\n  `nick_name` varchar(32) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Table structure for t_order_1\n-- ----------------------------\nDROP TABLE IF EXISTS `t_order_1`;\nCREATE TABLE `t_order_1` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n  `order_id` varchar(32) DEFAULT NULL COMMENT '顺序编号',\n  `user_id` varchar(32) DEFAULT NULL COMMENT '用户编号',\n  `userName` varchar(32) DEFAULT NULL COMMENT '用户名',\n  `passWord` varchar(32) DEFAULT NULL COMMENT '密码',\n  `user_sex` varchar(32) DEFAULT NULL,\n  `nick_name` varchar(32) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb4;\n```\n```\ntest_msg2 数据库2\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for t_order_0\n-- ----------------------------\nDROP TABLE IF EXISTS `t_order_0`;\nCREATE TABLE `t_order_0` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n  `order_id` varchar(32) DEFAULT NULL COMMENT '顺序编号',\n  `user_id` varchar(32) DEFAULT NULL COMMENT '用户编号',\n  `userName` varchar(32) DEFAULT NULL COMMENT '用户名',\n  `passWord` varchar(32) DEFAULT NULL COMMENT '密码',\n  `user_sex` varchar(32) DEFAULT NULL,\n  `nick_name` varchar(32) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=29 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Table structure for t_order_1\n-- ----------------------------\nDROP TABLE IF EXISTS `t_order_1`;\nCREATE TABLE `t_order_1` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',\n  `order_id` varchar(32) DEFAULT NULL COMMENT '顺序编号',\n  `user_id` varchar(32) DEFAULT NULL COMMENT '用户编号',\n  `userName` varchar(32) DEFAULT NULL COMMENT '用户名',\n  `passWord` varchar(32) DEFAULT NULL COMMENT '密码',\n  `user_sex` varchar(32) DEFAULT NULL,\n  `nick_name` varchar(32) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8mb4;\n```\n### 引入pom文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-parent</artifactId>\n    <version>2.1.5.RELEASE</version>\n    <relativePath/> <!-- lookup parent from repository -->\n  </parent>\n  <groupId>com.bmsoft</groupId>\n  <artifactId>share-jdbc</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <name>share-jdbc</name>\n  <description>Demo project for Spring Boot</description>\n\n  <properties>\n    <java.version>1.8</java.version>\n  </properties>\n\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter</artifactId>\n      <exclusions>\n        <exclusion>\n          <groupId>com.zaxxer</groupId>\n          <artifactId>HikariCP</artifactId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-test</artifactId>\n      <scope>test</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.mybatis.spring.boot</groupId>\n      <artifactId>mybatis-spring-boot-starter</artifactId>\n      <version>1.1.1</version>\n    </dependency>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-devtools</artifactId>\n      <optional>true</optional>\n    </dependency>\n\n    <dependency>\n      <groupId>org.projectlombok</groupId>\n      <artifactId>lombok</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid-spring-boot-starter</artifactId>\n      <exclusions>\n        <exclusion>\n          <groupId>org.slf4j</groupId>\n          <artifactId>slf4j-api</artifactId>\n        </exclusion>\n      </exclusions>\n      <version>1.1.10</version>\n    </dependency>\n    <!--sharding-jdbc -->\n    <dependency>\n      <groupId>com.dangdang</groupId>\n      <artifactId>sharding-jdbc-core</artifactId>\n      <version>1.5.4</version>\n    </dependency>\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n```\n\n### 数据源配置\n```\n#datasource\nspring.devtools.remote.restart.enabled=false\n\n#data source1\nspring.datasource.test1.driverClassName=com.mysql.jdbc.Driver\nspring.datasource.test1.url=jdbc:mysql://127.0.0.1:3306/test_msg1\nspring.datasource.test1.username=root\nspring.datasource.test1.password=root\n\n#data source2\nspring.datasource.test2.driverClassName=com.mysql.jdbc.Driver\nspring.datasource.test2.url=jdbc:mysql://127.0.0.1:3306/test_msg2\nspring.datasource.test2.username=root\nspring.datasource.test2.password=root\n```\n### 分库策略的简单实现\n\n```\n\nimport com.dangdang.ddframe.rdb.sharding.api.ShardingValue;\nimport com.dangdang.ddframe.rdb.sharding.api.strategy.database.SingleKeyDatabaseShardingAlgorithm;\nimport com.google.common.collect.Range;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n/**\n * 分库策略的简单实现\n */\npublic class ModuloDatabaseShardingAlgorithm implements SingleKeyDatabaseShardingAlgorithm<Long> {\n\n  @Override\n  public String doEqualSharding(Collection<String> databaseNames,\n      ShardingValue<Long> shardingValue) {\n    for (String each : databaseNames) {\n      if (each.endsWith(Long.parseLong(shardingValue.getValue().toString()) % 2 + \"\")) {\n        return each;\n      }\n    }\n    throw new IllegalArgumentException();\n  }\n\n  @Override\n  public Collection<String> doInSharding(Collection<String> databaseNames,\n      ShardingValue<Long> shardingValue) {\n    Collection<String> result = new LinkedHashSet<>(databaseNames.size());\n    for (Long value : shardingValue.getValues()) {\n      for (String tableName : databaseNames) {\n        if (tableName.endsWith(value % 2 + \"\")) {\n          result.add(tableName);\n        }\n      }\n    }\n    return result;\n  }\n\n  @Override\n  public Collection<String> doBetweenSharding(Collection<String> databaseNames,\n      ShardingValue<Long> shardingValue) {\n    Collection<String> result = new LinkedHashSet<>(databaseNames.size());\n    Range<Long> range = (Range<Long>) shardingValue.getValueRange();\n    for (Long i = range.lowerEndpoint(); i <= range.upperEndpoint(); i++) {\n      for (String each : databaseNames) {\n        if (each.endsWith(i % 2 + \"\")) {\n          result.add(each);\n        }\n      }\n    }\n    return result;\n  }\n}\n\n```\n\n### 分表的策略实现\n\n``` \nimport com.dangdang.ddframe.rdb.sharding.api.ShardingValue;\nimport com.dangdang.ddframe.rdb.sharding.api.strategy.table.SingleKeyTableShardingAlgorithm;\nimport com.google.common.collect.Range;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\n\n/**\n * 分表策略的基本实现\n */\npublic class ModuloTableShardingAlgorithm implements SingleKeyTableShardingAlgorithm<Long> {\n\n  @Override\n  public String doEqualSharding(Collection<String> tableNames, ShardingValue<Long> shardingValue) {\n    for (String each : tableNames) {\n     /* if (each.endsWith(shardingValue.getValue() % 2 + \"\")) {\n        return each;\n      }*/\n      if (each.endsWith(shardingValue.getValue() + \"\")) {\n        return each;\n      }\n    }\n    throw new IllegalArgumentException();\n  }\n\n  @Override\n  public Collection<String> doInSharding(Collection<String> tableNames,\n      ShardingValue<Long> shardingValue) {\n    Collection<String> result = new LinkedHashSet<>(tableNames.size());\n    for (Long value : shardingValue.getValues()) {\n      for (String tableName : tableNames) {\n        /*if (tableName.endsWith(value % 2 + \"\")) {\n          result.add(tableName);\n        }*/\n        if (tableName.endsWith(value + \"\")) {\n          result.add(tableName);\n        }\n      }\n    }\n    return result;\n  }\n\n  @Override\n  public Collection<String> doBetweenSharding(Collection<String> tableNames,\n      ShardingValue<Long> shardingValue) {\n    Collection<String> result = new LinkedHashSet<>(tableNames.size());\n    Range<Long> range = (Range<Long>) shardingValue.getValueRange();\n    for (Long i = range.lowerEndpoint(); i <= range.upperEndpoint(); i++) {\n      for (String each : tableNames) {\n       /* if (each.endsWith(i % 2 + \"\")) {\n          result.add(each);\n        }*/\n        if (each.endsWith(i + \"\")) {\n          result.add(each);\n        }\n\n      }\n    }\n    return result;\n  }\n}\n\n```\n### 数据源初始化、绑定分库分表策略\n\n```\n/**\n * 分库分表最主要有几个配置： 有多少个数据源 每张表的逻辑表名和所有物理表名 用什么列进行分库以及分库算法 用什么列进行分表以及分表算法 分为两个库：test_msg1 , test_msg2，\n * 每个库都包含两个表: t_order_0 , t_order_1 使用user_id作为分库列； 使用order_id作为分表列；\n */\n@Configuration\n@MapperScan(basePackages = \"com.bmsoft.sharejdbc.mapper\", sqlSessionTemplateRef = \"test1SqlSessionTemplate\")\npublic class DataSourceConfig {\n\n  /**\n   * 配置数据源0，数据源的名称最好要有一定的规则，方便配置分库的计算规则\n   */\n  @Bean(name = \"dataSource0\")\n  @ConfigurationProperties(prefix = \"spring.datasource.test1\")\n  public DataSource dataSource0() {\n    return new DruidDataSource();\n  }\n\n  /**\n   * 配置数据源1，数据源的名称最好要有一定的规则，方便配置分库的计算规则\n   */\n  @Bean(name = \"dataSource1\")\n  @ConfigurationProperties(prefix = \"spring.datasource.test2\")\n  public DataSource dataSource1() {\n    return new DruidDataSource();\n  }\n\n  /**\n   * 配置数据源规则，即将多个数据源交给sharding-jdbc管理，并且可以设置默认的数据源， 当表没有配置分库规则时会使用默认的数据源\n   */\n  @Bean\n  public DataSourceRule dataSourceRule(\n      @Qualifier(\"dataSource0\") DataSource dataSource0  , @Qualifier(\"dataSource1\") DataSource dataSource1) {\n    //设置分库映射\n    Map<String, DataSource> dataSourceMap = new HashMap<>();\n    dataSourceMap.put(\"dataSource0\", dataSource0);\n    dataSourceMap.put(\"dataSource1\", dataSource1);\n    //设置默认库，两个库以上时必须设置默认库。默认库的数据源名称必须是dataSourceMap的key之一\n    return new DataSourceRule(dataSourceMap, \"dataSource0\");\n  }\n\n  /**\n   * 配置数据源策略和表策略，具体策略需要自己实现\n   */\n  @Bean\n  public ShardingRule shardingRule(DataSourceRule dataSourceRule) {\n    //具体分库分表策略\n    TableRule orderTableRule = TableRule.builder(\"t_order\")\n        .actualTables(Arrays.asList(\"t_order_1\", \"t_order_2\"))\n        .tableShardingStrategy(\n            new TableShardingStrategy(\"order_id\", new ModuloTableShardingAlgorithm()))\n        .dataSourceRule(dataSourceRule)\n        .build();\n\n    //绑定表策略，在查询时会使用主表策略计算路由的数据源，因此需要约定绑定表策略的表的规则需要一致，可以一定程度提高效率\n    List<BindingTableRule> bindingTableRules = new ArrayList<BindingTableRule>();\n    bindingTableRules.add(new BindingTableRule(Arrays.asList(orderTableRule)));\n    return ShardingRule.builder()\n        .dataSourceRule(dataSourceRule)\n        .tableRules(Arrays.asList(orderTableRule))\n        .bindingTableRules(bindingTableRules)\n        .databaseShardingStrategy(\n            new DatabaseShardingStrategy(\"user_id\", new ModuloDatabaseShardingAlgorithm()))\n        .tableShardingStrategy(\n            new TableShardingStrategy(\"order_id\", new ModuloTableShardingAlgorithm()))\n        .build();\n  }\n\n  /**\n   * 创建sharding-jdbc的数据源DataSource，MybatisAutoConfiguration会使用此数据源\n   */\n  @Bean(name = \"dataSource\")\n  public DataSource shardingDataSource(ShardingRule shardingRule) throws SQLException {\n    return ShardingDataSourceFactory.createDataSource(shardingRule);\n  }\n\n  /**\n   * 需要手动配置事务管理器\n   */\n  @Bean\n  public DataSourceTransactionManager transactitonManager(\n      @Qualifier(\"dataSource\") DataSource dataSource) {\n    return new DataSourceTransactionManager(dataSource);\n  }\n\n  @Bean(name = \"test1SqlSessionFactory\")\n  @Primary\n  public SqlSessionFactory testSqlSessionFactory(@Qualifier(\"dataSource\") DataSource dataSource)\n      throws Exception {\n    SqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n    bean.setDataSource(dataSource);\n    bean.setMapperLocations(\n        new PathMatchingResourcePatternResolver().getResources(\"classpath:mybatis/mapper/*.xml\"));\n    return bean.getObject();\n  }\n\n  @Bean(name = \"test1SqlSessionTemplate\")\n  @Primary\n  public SqlSessionTemplate testSqlSessionTemplate(\n      @Qualifier(\"test1SqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception {\n    return new SqlSessionTemplate(sqlSessionFactory);\n  }\n}\n```\nmapper 接口\n\n```\npublic interface User1Mapper {\n\n  List<UserEntity> getAll(UserEntity userEntity);\n\n  void insert(UserEntity user);\n}\n```\nxml \n\n```\n<select id=\"getAll\" resultMap=\"BaseResultMap\"  parameterType=\"com.bmsoft.sharejdbc.entity.UserEntity\" >\n    SELECT\n    <include refid=\"Base_Column_List\" />\n    FROM t_order\n<where>\n  <if test=\"user_id!=null\">\n    user_id = #{user_id}\n  </if>\n  <if test=\"order_id!=null\">\n    and order_id = #{order_id}\n  </if>\n</where>\n  </select>\n\n  <insert id=\"insert\" parameterType=\"com.bmsoft.sharejdbc.entity.UserEntity\" >\n    INSERT INTO\n    t_order\n    (order_id,user_id,userName,passWord,user_sex)\n    VALUES\n    (#{order_id},#{user_id},#{userName}, #{passWord}, #{userSex})\n  </insert>\n  ```\n\nUser1Service\n```\nprivate User1Mapper user1Mapper;\n\n  public List<UserEntity> getUsers(UserEntity userEntity) {\n    List<UserEntity> users = user1Mapper.getAll(userEntity);\n    return users;\n  }\n\n  //    @Transactional(value=\"test1TransactionManager\",rollbackFor = Exception.class,timeout=36000)\n  // 说明针对Exception异常也进行回滚，如果不标注，则Spring 默认只有抛出 RuntimeException才会回滚事务\n  public void updateTransactional(UserEntity user) {\n    try {\n      user1Mapper.insert(user);\n      log.error(String.valueOf(user));\n    } catch (Exception e) {\n      log.error(\"find exception!\");\n      // 事物方法中，如果使用trycatch捕获异常后，需要将异常抛出，否则事物不回滚。\n      throw e;\n    }\n\n  }\n  ```\n\n  说明，\n  1、查询所有的会把不同库和不同表的数据一起查询组合，新增时，会根据user_id分库，order_id 分表\n  2、分库分表，需要定义主键保持全库唯一，这边没有处理\n\n### 启动项配置\n  ```\n  @SpringBootApplication(exclude={DataSourceAutoConfiguration.class})\n@EnableTransactionManagement(proxyTargetClass = true)   //开启事物管理功能\npublic class ShareJdbcApplication {\n\n  public static void main(String[] args) {\n    SpringApplication.run(ShareJdbcApplication.class, args);\n  }\n}\n\n```\n\n","tags":["-多数据源 -分库分表"]},{"title":"springboot多数据源切换注解方式","url":"/2019/07/03/springboot多数据源切换注解方式/","content":"\n# springboot多数据源切换注解方式\n\n## 配置连接数据库信息\n```\nspring.datasource.inner.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.inner.url=jdbc:mysql://\nspring.datasource.inner.username=root\nspring.datasource.inner.password=root \n\nspring.datasource.third.type=com.alibaba.druid.pool.DruidDataSource\nspring.datasource.third.url=jdbc:mysql:\nspring.datasource.third.username=root\nspring.datasource.third.password=root \n```\n## 数据源配置\n\n```\n@Configuration\npublic class DbDuridMysqlProperties {\n\n  @Autowired\n  private DataSourceProperties dataSourceProperties;\n\n  @Bean(name = \"innerDataSource\", destroyMethod = \"close\", initMethod = \"init\")\n  @ConfigurationProperties(\"spring.datasource.inner\")\n  public DataSource innerDataSource() throws SQLException {\n    DruidDataSource druidDataSource = new DruidDataSource();\n    setDataSourcePool(druidDataSource);\n    return druidDataSource;\n  }\n\n  @Bean(name = \"thirdDataSource\", destroyMethod = \"close\", initMethod = \"init\")\n  @ConfigurationProperties(\"spring.datasource.third\")\n  public DataSource thirdDataSource() throws SQLException {\n    DruidDataSource druidDataSource = new DruidDataSource();\n    setDataSourcePool(druidDataSource);\n    return druidDataSource;\n  }\n}\n```\n\n## 动态数据源持有者\n```\n/**\n * 动态数据源持有者，负责利用ThreadLocal存取数据源名称\n */\npublic class DynamicDataSourceHolder {\n\n  /**\n   * 本地线程共享对象\n   */\n  private static final ThreadLocal<String> THREAD_LOCAL = new ThreadLocal<>();\n\n  public static void putDataSource(String name) {\n    THREAD_LOCAL.set(name);\n  }\n\n  public static String getDataSource() {\n    return THREAD_LOCAL.get();\n  }\n\n  public static void removeDataSource() {\n    THREAD_LOCAL.remove();\n  }\n}\n```\n\n## 动态数据源实现类\n\n```\n/**\n * 动态数据源实现类\n */\n@Slf4j\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n  //数据源路由，此方用于产生要选取的数据源逻辑名称\n  @Override\n  protected Object determineCurrentLookupKey() {\n    //从共享线程中获取数据源名称\n    return DynamicDataSourceHolder.getDataSource();\n  }\n}\n```\n\n## 定于数据源注解,主要用于dao切换数据源\n```\n/**\n * 目标数据源注解，注解在方法上指定数据源的名称\n */\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface TargetDataSource {\n\n  //此处接收的是数据源的名称\n  String value();\n}\n```\n## 数据源配置,加载配置的数据源，形成key - 数据源\n```\npackage com.bmsoft.newborn.config.datasource;\n\nimport com.bmsoft.newborn.config.dds.DynamicDataSource;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport lombok.extern.slf4j.Slf4j;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.PlatformTransactionManager;\n\n/**\n * 数据源配置\n */\n@Configuration\n@Slf4j\n@MapperScan({\"com.bmsoft.newborn.mapper.inner\", \"com.bmsoft.newborn.mapper.third\"})\npublic class DataSourceConfig {\n\n\n  @Autowired\n  private DbDuridMysqlProperties duridMysqlProperties;\n\n\n  /**\n   * @Primary 该注解表示在同一个接口有多个实现类可以注入的时候，默认选择哪一个，而不是让@autowire注解报错\n   * @Qualifier 根据名称进行注入，通常是在具有相同的多个类型的实例的一个注入（例如有多个DataSource类型的实例）\n   */\n  @Bean(name = \"dataSource\")\n  @Primary\n  public DynamicDataSource dataSource() throws SQLException {\n    //按照目标数据源名称和目标数据源对象的映射存放在Map中\n    //采用是想AbstractRoutingDataSource的对象包装多数据源\n    DynamicDataSource dynamicDataSource = new DynamicDataSource();\n    Map<Object, Object> targetDataSources = new HashMap<>();\n    targetDataSources.put(\"inner\", duridMysqlProperties.innerDataSource());\n    targetDataSources.put(\"third\", duridMysqlProperties.thirdDataSource());\n\n    dynamicDataSource.setTargetDataSources(targetDataSources);\n    //设置默认的数据源，当拿不到数据源时，使用此配置\n    dynamicDataSource.setDefaultTargetDataSource(duridMysqlProperties.innerDataSource());\n    return dynamicDataSource;\n  }\n\n  //开启事务\n  @Bean\n  public PlatformTransactionManager txManager() throws SQLException {\n    return new DataSourceTransactionManager(dataSource());\n  }\n\n\n}\n```\n\n##  数据源AOP切面定义\n```\npackage com.bmsoft.newborn.config.datasource;\n\nimport com.bmsoft.newborn.annotation.TargetDataSource;\nimport com.bmsoft.newborn.config.dds.DynamicDataSourceHolder;\nimport java.lang.reflect.Method;\nimport lombok.extern.slf4j.Slf4j;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.core.env.Environment;\nimport org.springframework.stereotype.Component;\n\n/**\n * 数据源AOP切面定义\n */\n@Component\n@Aspect\n@Slf4j\n@Order(4)\npublic class DataSourceAspect {\n\n  @Autowired\n  private Environment env;\n\n\n  //切换放在mapper接口的方法上，所以这里要配置AOP切面的切入点\n  @Pointcut(\"execution( * com.bmsoft.newborn.mapper.*.*.*(..))\")\n  public void dataSourcePointCut() {\n  }\n\n  @Before(\"dataSourcePointCut()\")\n  public void before(JoinPoint joinPoint) throws Exception {\n    Object target = joinPoint.getTarget();\n    /**\n     * Signature 包含了方法名、申明类型以及地址等信息\n     */\n    //方法名称\n    String method = joinPoint.getSignature().getName();\n    //参数值\n    Object[] paramValues = joinPoint.getArgs();\n    Class<?>[] clazz = target.getClass().getInterfaces();\n    Class<?>[] parameterTypes = ((MethodSignature) joinPoint.getSignature()).getMethod()\n        .getParameterTypes();\n    //获取参数类型\n    try {\n      //类上或者方法上存在注解\n      Method m = clazz[0].getMethod(method, parameterTypes);\n      Class<?> declaringClass = m.getDeclaringClass();\n      if (declaringClass.isAnnotationPresent(TargetDataSource.class)) {\n        TargetDataSource data = declaringClass.getAnnotation(TargetDataSource.class);\n        changeDataSource(data);\n      } else if (m.isAnnotationPresent(TargetDataSource.class)) {\n        TargetDataSource data = m.getAnnotation(TargetDataSource.class);\n        //可以根据参数获取当前数据源\n        changeDataSource(data);\n      }\n    } catch (Exception e) {\n      log.error(\"当前线程 \" + Thread.currentThread().getName() + \" 添加数据源失败\", e);\n    }\n  }\n\n  private void changeDataSource(TargetDataSource data) {\n    //可以根据参数获取当前数据源\n    String deafultSourceName = data.value();\n    log.info(\n            \"使用数据源 \" + Thread.currentThread().getName() + \" 添加数据源到-- \" + deafultSourceName\n                    + \" 本地线程变量\");\n    DynamicDataSourceHolder.putDataSource(deafultSourceName);\n  }\n\n  private void changeDataSource(Object[] paramValues, TargetDataSource data) {\n    //可以根据参数获取当前数据源\n    String deafultSourceName = data.value();\n    if (paramValues != null && paramValues.length > 0) {\n      log.info(\n          \"使用数据源 \" + Thread.currentThread().getName() + \" 添加数据源到-- \" + deafultSourceName\n              + \" 本地线程变量\");\n      DynamicDataSourceHolder.putDataSource(deafultSourceName);\n    }\n  }\n\n\n  //执行完切面后，将线程共享中的数据源名称清空\n  @After(\"dataSourcePointCut()\")\n  public void after(JoinPoint joinPoint) {\n    DynamicDataSourceHolder.removeDataSource();\n  }\n\n\n}\n```\n## springboot 关闭数据源自动配置，改为手动配置\n```\npackage com.bmsoft.newborn;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\n\n@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)\npublic class MicroNewbornServiceApplication {\n\n  @Bean\n  public BCryptPasswordEncoder bCryptPasswordEncoder() {\n    return new BCryptPasswordEncoder();\n  }\n\n  public static void main(String[] args) {\n    SpringApplication.run(MicroNewbornServiceApplication.class, args);\n  }\n\n}\n```\n\n## 在mapper接口上使用数据源注解到目标数据源\n```\npackage com.bmsoft.newborn.mapper.inner;\n\n\nimport com.bmsoft.newborn.annotation.TargetDataSource;\nimport com.bmsoft.newborn.domain.inner.Dict;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.List;\n\n@TargetDataSource(\"inner\")\npublic interface DictMapper  {\n\n  Dict selectById(@Param(\"code\") String code);\n\n  List<Dict> selectAllDict();\n\n}\n```\n## 注意\n1、同一个service中如果启动事务注解@Transaction，数据源切换将不起作用，需要改为分布式事务\n2、需要注意配置默认的数据源，不然在非注解的情况下，查询SQL会报错\n3、在aop 切换数据源时，可以在mapper中传入固定的参数，解析参数可以做切换数据源处理,利用反射获取主键方法的方法传参值进行切换\n```\n\n/**\n * 数据源AOP切面定义\n */\n@Component\n@Aspect\n@Slf4j\n@Order(4)\n@PropertySource(\"classpath:datasource.properties\")//这是多数据源属性文件路径\npublic class DataSourceAspect {\n\n    @Autowired\n    private Environment env;\n\n\n    //切换放在mapper接口的方法上，所以这里要配置AOP切面的切入点\n    @Pointcut(\"execution( * com.bmsoft.wfy.mapper.*.*.*(..))\")\n    public void dataSourcePointCut() {\n    }\n\n    @Before(\"dataSourcePointCut()\")\n    public void before(JoinPoint joinPoint) throws Exception {\n        Object target = joinPoint.getTarget();\n        /**\n         * Signature 包含了方法名、申明类型以及地址等信息\n         */\n        String class_name = joinPoint.getTarget().getClass().getName();\n\n        //方法名称\n        String method = joinPoint.getSignature().getName();\n        //参数值\n        Object[] paramValues = joinPoint.getArgs();\n        Class<?>[] clazz = target.getClass().getInterfaces();\n        Class<?>[] parameterTypes = ((MethodSignature) joinPoint.getSignature()).getMethod().getParameterTypes();\n        //获取参数类型\n        try {\n            Method m = clazz[0].getMethod(method, parameterTypes);\n            //如果方法上存在切换数据源的注解，则根据注解内容进行数据源切换\n            if (m != null && m.isAnnotationPresent(TargetDataSource.class)) {\n                TargetDataSource data = m.getAnnotation(TargetDataSource.class);\n                //可以根据参数获取当前数据源\n                String deafultSourceName = data.value();\n                if (paramValues != null && paramValues.length > 0) {\n                    for (int i = 0; i < paramValues.length; i++) {\n                        log.info(\"数据源方法\" + method);\n                        log.info(\"请求参数类型\" + parameterTypes[i]);\n                        if (parameterTypes[i] == Map.class) {\n                            log.info(\"Map类型值\" + paramValues[i]);\n                            Map<String, Object> map = (HashMap) paramValues[i];\n                            log.info(\"转换之后的Map类型值\" + map);\n                            //获取法院代码\n                            Object courtNumber = map.get(\"courtNumber\");\n                            String court =\"\";\n                            if(courtNumber!=null){\n                                court =String.valueOf(courtNumber);\n                            }\n                            changeDataSource(deafultSourceName, courtNumber, court);\n\n                        } else if (parameterTypes[i] == List.class) {\n                            log.info(\"List类型值\" + paramValues[i]);\n                        } else {\n                            log.info(\"对象类型值\" + paramValues[i]);\n                            final Map<String, String> stringStringMap = obj2Map(paramValues[i]);\n                            log.info(\"对象转为map后的值\" + stringStringMap);\n                            Object courtNumber = stringStringMap.get(\"courtNumber\");\n                            String court =\"\";\n                            if(courtNumber!=null){\n                                court =String.valueOf(courtNumber);\n                            }\n                            changeDataSource(deafultSourceName, courtNumber, court);\n                        }\n\n                    }\n                }\n            } else {\n                //TODO,默认MySQL数据源的处理\n                //mapper 接口没有数据源注解,使用MySQL数据库\n                log.info(\"使用默认mysql数据源\");\n            }\n        } catch (Exception e) {\n            log.error(\"当前线程 \" + Thread.currentThread().getName() + \" 添加数据源失败\", e);\n        }\n    }\n\n    //更换连接的数据源\n    private void changeDataSource(String deafultSourceName, Object courtNumber, String court) {\n        if (StringUtils.isNotBlank(court)&& !\"\".equals(court) &&!\"null\".equalsIgnoreCase(court)&&court.length()>=4) {\n            court = court.substring(0, 4);\n            //TODO,当前只有一个Sybase数据库,后期多个进行扩展\n            if ( StringUtils.isNotBlank(deafultSourceName)&&deafultSourceName.indexOf(\"sybase\") != -1) {\n                String key = \"datasource.sybase.\" + court;\n                //使用 3200 3201 3202  \n                String dataSourceName = env.getProperty(key);\n                DynamicDataSourceHolder.putDataSource(dataSourceName);\n                log.info(\"使用线程 \" + Thread.currentThread().getName() + \" sybase添加--案件 \" + \"法院代码---\" + courtNumber + \"--的数据源----\" + dataSourceName + \" 本地线程变量\");\n\n            } else if( StringUtils.isNotBlank(deafultSourceName)&&deafultSourceName.indexOf(\"mysql\") != -1){\n                //使用其他库的判断\n                String key = \"datasource.mysql.\" + court;\n                //使用 3200 3201 3202  \n                String dataSourceName = env.getProperty(key);\n                DynamicDataSourceHolder.putDataSource(dataSourceName);\n                log.info(\"使用线程 \" + Thread.currentThread().getName() + \"mysql 添加--执行 \" + \"法院代码---\" + courtNumber + \"--的数据源----\" + dataSourceName + \" 本地线程变量\");\n\n            }else if( StringUtils.isNotBlank(deafultSourceName)&&deafultSourceName.indexOf(\"oa\") != -1){\n                //使用其他库的判断\n                //log.info(\"使用线程 \" + Thread.currentThread().getName() + \"sybaseoa 添加--执行 \" + \"法院代码---\" + courtNumber + \"--的数据源----\" + dataSourceName + \" 本地线程变量\");\n                log.info(\"使用默认江苏高院OA\");\n\n                String key = \"datasource.oa.3200\";\n                //使用 3200 3201 3202 的办公oa\n                String dataSourceName = env.getProperty(key);\n                DynamicDataSourceHolder.putDataSource(dataSourceName);\n                log.info(\"使用线程 \" + Thread.currentThread().getName() + \"sybaseoa 添加--执行 \" + \"法院代码---\" + courtNumber + \"--的数据源----\" + dataSourceName + \" 本地线程变量\");\n            }\n        } else {\n            //TODO,没有传法院代码的情况默认使用集中库\n            //判断注解上的值,为集中库上的值\n            if (\"sybaseTtre\".equalsIgnoreCase(deafultSourceName)) {\n                DynamicDataSourceHolder.putDataSource(deafultSourceName);\n                log.info(\"使用Sybase集中库线程 \" + Thread.currentThread().getName() + \" 添加数据源到-- \" + deafultSourceName + \" 本地线程变量\");\n            }else{\n                //TODO 当事人测试使用,后期会更改\n                DynamicDataSourceHolder.putDataSource(\"sybaseTtre\");\n                log.info(\"使用Sybase集中库线程 \" + Thread.currentThread().getName() + \" 添加数据源到-- \" + deafultSourceName + \" 本地线程变量\");\n                //TODO,目前不传法院代码,只有一个集中库的情况,后期进行扩展\n            }\n        }\n    }\n\n    private static Map<String, String> obj2Map(Object obj) {\n        Map<String, String> map = new HashMap<String, String>();\n        // System.out.println(obj.getClass());\n        // 获取f对象对应类中的所有属性域\n        Field[] fields = obj.getClass().getDeclaredFields();\n        for (int i = 0, len = fields.length; i < len; i++) {\n            String varName = fields[i].getName();\n            //varName = varName.toLowerCase();//将key置为小写，默认为对象的属性\n            try {\n                // 获取原来的访问控制权限\n                boolean accessFlag = fields[i].isAccessible();\n                // 修改访问控制权限\n                fields[i].setAccessible(true);\n                // 获取在对象f中属性fields[i]对应的对象中的变量\n                Object o = fields[i].get(obj);\n                if (o != null) {\n                    map.put(varName, o.toString());\n                }\n                // System.out.println(\"传入的对象中包含一个如下的变量：\" + varName + \" = \" + o);\n                // 恢复访问控制权限\n                fields[i].setAccessible(accessFlag);\n            } catch (IllegalArgumentException ex) {\n                ex.printStackTrace();\n            } catch (IllegalAccessException ex) {\n                ex.printStackTrace();\n            }\n        }\n        return map;\n    }\n\n    //执行完切面后，将线程共享中的数据源名称清空\n    @After(\"dataSourcePointCut()\")\n    public void after(JoinPoint joinPoint) {\n        DynamicDataSourceHolder.removeDataSource();\n    }\n\n    public static void main(String[] args) {\n        String courtNumer = \"320100\";\n        System.out.println(courtNumer.substring(0, 4));\n    }\n    \n}\n\n```","tags":["-多数据源"]},{"title":"nginx离线安装过程","url":"/2019/07/02/nginx离线安装过程/","content":"\n# nginx 离线安装过程 \n1、安装gcc gcc++ 依赖\n\na、首先现在了nginx的最新版本nginx-1.10.0.tar.gz，上传到服务器(/usr/local/src/nginx)目录\n\nb、解压tar -zxvf nginx-1.10.0.tar.gz\n\nc、进入解压目录执行./configure, 这里用到了gcc、pcre、zlib库，如果没有安装会出现C compiler cc is not found等错误\n\ngcc依赖库下载地址：http://download.csdn.net/detail/yidragon88xx/9903875\n\n## 1)、安装gcc库\n仓库地址 http://vault.centos.org/6.5/os/x86_64/Packages/ 包仓库\nrpm -ivh mpfr-2.4.1-6.el6.x86_64.rpm\nrpm -ivh mpfr-2.4.1-6.el6.x86_64.rpm\nrpm -ivh ppl-0.10.2-11.el6.x86_64.rpm\nrpm -ivh cloog-ppl-0.15.7-1.2.el6.x86_64.rpm\nrpm -ivh cpp-4.4.7-17.el6.x86_64.rpm\nrpm -Uvh libgcc-4.4.7-17.el6.x86_64.rpm\nrpm -Uvh libgomp-4.4.7-17.el6.x86_64.rpm\nrpm -ivh glibc-2.12-1.192.el6.x86_64.rpm\nrpm -ivh glibc-headers-2.12-1.192.el6.x86_64.rpm\nrpm -ivh glibc-devel-2.12-1.192.el6.x86_64.rpm\nrpm -ivh gcc-4.4.7-17.el6.x86_64.rpm\n\n## 2）、安装pcre库\n\npcre下载地址：http://download.csdn.net/detail/yidragon88xx/9903904\n\nrpm -ivh pcre-devel-7.8-7.el6.x86_64.rpm\n\n## 3）、安装zlib库\n\nzlib下载地址：http://download.csdn.net/detail/yidragon88xx/9903920\n\nrpm -ivh zlib-devel-1.2.3-3.x86_64.rpm\n\n如果安装过程中还出现其他库没有安装的情况，可以从如下网址中搜索：\n\nhttps://centos.pkgs.org\nhttp://rpm.pbone.net/\nhttp://www.rpm-find.net/\n安装如果报错\nerror while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory，意思是找不到libpcre.so.1这个模块，而导致启动失败。\n\n解决方法如下\n如果是32位系统\n\n[root@lee ~]#  ln -s /usr/local/lib/libpcre.so.1 /lib\n\n如果是64位系统\n\n[root@lee ~]#  ln -s /usr/local/lib/libpcre.so.1 /lib64\n\n\nd、依赖库都安装完成之后然后重新执行\n\n./configure\n\n编译过程中会出现很多信息有些是not found信息，这些不用关心，只要在最后出现，表示编译成功\n\nConfiguration summary\n+ using system PCRE library\n+ OpenSSL library is not used\n+ md5: using system crypto library\n+ sha1 library is not used\n+ using system zlib library \n\ne、执行make\n\nf、执行make install\n\ng、nginx就安装完成了，然后进入/usr/local/目录发现生成新文件夹nginx表示安装成了\n\nh、进入nginx根目录的sbin下执行./nginx启动nginx\n\ni、查看启动情况\n\nps -ef|grep nginx\n\n## 4）配置NGINX 环境变量\n\nexport HGINX_HOME=/usr/local/nginx\nexport PATH=$PATH:$HGINX_HOME/sbin\n \n## 5）配置NGINX开机自启动\n\n\t1.写自启动脚本\n\t2.设置权限\n\tchmod 777 /etc/init.d/nginx\n\t3.设置开机默认启动\n\tchkconfig --add nginx //添加系统服务\n\tchkconfig --level 345 nginx on //设置开机启动,启动级别\n\tchkconfig --list nginx //查看开机启动配置信息\n## nginx控制命令\n\nservice nginx start   #开启\nservice nginx stop    #停止\nservice nginx restart #重启\nservice nginx reload  #重新加载\n","tags":["-NGINX"]},{"title":"windows批处理操作指令","url":"/2019/07/02/windows批处理操作指令/","content":"\n## Windows环境下运行bat指令\n\n-Windows下 初始化MySQL SQL 文件\n\n```\n@echo off　\nstart  cmd /k   \"echo initmysql  &&  title init-mysql  && cd/d  D:\\soft\\mysql-5.7.26-winx64\\bin && mysql -h localhost  -uroot -pnrqzdhlscx2 -Dtest < D:\\soft\\initmysql.sql\"\n\n```\n\n-windows 下，打开多个窗口运行springboot jar包\n\n```\n@echo off　\nstart  cmd /c   \"echo Starting graph-eureka-server &&  title graph-eureka-server &&  java -jar   D:\\soft\\java-service\\graph-eureka-server.jar \"\n\nstart  cmd /c  \"echo Starting link-excel &&  title link-excel &&  java -Dfile.encoding=UTF-8  -jar  D:\\soft\\java-service\\link-excel.jar\" \n\nstart  cmd /c  \"echo Starting link-web  &&  title link-web &&  java -jar   D:\\soft\\java-service\\link-web.jar\" \n\nstart  cmd /c  \"echo Starting link-graph1  &&  title link-graph1 &&  java -jar D:\\soft\\java-service\\link-graph1.jar\"\n```\n\n-Windows 下关闭多个Java 虚拟机\n\n```\ntaskkill /f /t /fi  \"imagename eq java.exe\" \n```\n\n ## 备注\n\n 1、echo 命令 \n 打开回显或关闭请求回显功能，或显示消息。如果没有任何参数，echo 命令将显示当前回显设置。\n语法\necho [{ on|off }] [message]\n\n\n2、rem 命令，注释，代表此行不会执行\n\nrem 这是一个注释\n\n3、pause 命令\n    这是一个暂停指令，按任意键继续\n\n4、start 命令\n\nStart语法\nstart [\"title\"] [/dPath] [/min] [/max] [{/separate |/shared}] [{/low | /normal | /high | /realtime | /abovenormal | belownormal}][/wait] [/B] [FileName] [parameters]\n\n启动单独的“命令提示符”窗口来运行指定程序或命令。如果在没有参数的情况下使用，start 将打开第二个命令提示符窗口。\n\nstart cmd/c 打开新窗口执行指令后关闭窗口\n\nstart cmd/k 打开新窗口执行指令后,保持新窗口\n\ntitle 新窗口的标题名称\n\n5、taskkill 指令，使用该工具按照进程 ID (PID) 或映像名称终止任务。\n\n```\nTASKKILL [/S system [/U username [/P [password]]]]   \n         { [/FI filter] [/PID processid | /IM imagename] } [/T] [/F]\n\n```\n```\n1. /S    system    指定要连接的远程系统。  \n\n2. /U    [domain\\]user    指定应该在哪个用户上下文执行这个命令。\n\n3. /P    [password]       为提供的用户上下文指定密码。如果忽略，提示输入。\n\n4. /FI   filter           应用筛选器以选择一组任务。允许使用 \"*\"。例如，映像名称 eq acme*\n\n5. /PID  processid        指定要终止的进程的 PID。使用 TaskList 取得 PID。\n\n6. /IM   imagename        指定要终止的进程的映像名称。通配符 '*'可用来 指定所有任务或映像名称。\n\n7. /T                     终止指定的进程和由它启用的子进程。\n\n8. /F                     指定强制终止进程。\n\n9. /?                     显示帮助消息\n\n```\n例子，杀死对应进程：\ntaskkill /pid pid  \n\ntaskkill /im xxx.exe  \n\ntaskkill /fi \"imagename eq xxx.exe\"  \n\ntaskkill /fi \"pid eq pid\"  ","tags":["-Windows批处理"]},{"title":"git学习教程","url":"/2019/07/02/git学习教程/","content":"\n# git 学习教程\n\ngit init \ngit add  \ngit commit -m \ngit status \ngit diff\ngit log 查看版本记录\n\ngit log --pretty=oneline ,注意commitID是16进制字符串\n\ngit reset --HEAD^ 返回上个版本, HEAD^^返回上上个版本\n\ngit reset --hard commitid,返回指定版本\n\ngit返回版本非常快，因为Git内部有个指向当前版本的HEAD指针，改变版本只需要改变指针指向就可以了。\n\ngit reflog 用来记录你的每一次指令，用于查看版本变化。\n\n\n## 概念\n工作区 ：自己创建文件或者文件夹的位置，创建修改文件的地方\n\n版本库：工作区隐藏的。git目录，这个不算工作区，是版本库，版本库存stage 暂存区 ，还有主动创建的master 分支\n\n以及执行master的head指针。\n\ngit add 命令就是要把提交的所有修改都放到stage 暂存区里，然后指向commit命令一次性把\n暂存区里的所有修改提交到分支上去。\nUntracked 新增的文件还没有被修改过\n\ngit 跟踪和管理的是工作区的修改，并非文件，每次工作区的修改都要git add添加到暂存区，最后可以统一commit\n\ngit checkout -- readme.txt ，丢弃工作区的修改，对暂存区不起作用\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n\n如果git add readme.txt 添加到暂存区，撤销修改的话\n1.需要用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：\n\n2。然后在丢弃工作区的修改git checkout -- readme.txt \n\n撤销修改\n\n \n自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：\n\n```\n$ cat readme.txt\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\nMy stupid boss still prefers SVN.\n```\n在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！\n\n既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：\n\n$ git status\n```\n# On branch master\n# Changes not staged for commit:\n#   (use \"git add <file>...\" to update what will be committed)\n#   (use \"git checkout -- <file>...\" to discard changes in working directory)\n#\n#       modified:   readme.txt\n#\n```\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改：\n\n$ git checkout -- readme.txt\n命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：\n\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n\n现在，看看readme.txt的文件内容：\n\n```\n$ cat readme.txt\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n```\n文件内容果然复原了。\n\ngit checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。\n\n\n现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：\n\n```\n$ cat readme.txt\nGit is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\nMy stupid boss still prefers SVN.\n```\n$ git add readme.txt\n庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：\n\n$ git status\n```\n# On branch master\n# Changes to be committed:\n#   (use \"git reset HEAD <file>...\" to unstage)\n#\n#       modified:   readme.txt\n#\n```\nGit同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：\n\n$ git reset HEAD readme.txt\nUnstaged changes after reset:\nM       readme.txt\ngit reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。\n\n再用git status查看一下，现在暂存区是干净的，工作区有修改：\n\n$ git status\n```\n# On branch master\n# Changes not staged for commit:\n#   (use \"git add <file>...\" to update what will be committed)\n#   (use \"git checkout -- <file>...\" to discard changes in working directory)\n#\n#       modified:   readme.txt\n#\n```\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n还记得如何丢弃工作区的修改吗？\n\n$ git checkout -- readme.txt\n\n\n$ git status\n```\n# On branch master\nnothing to commit (working directory clean)\n```\n整个世界终于清静了！\n\n\n现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……\n\n小结\n\n又到了小结时间。\n\n场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。\n\n场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。\n\n场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。\n\n\n\n## 删除 \n\n一种是删除\nrm 删除后 git rm 删除，git commit 提交修改\n一种是删错了，恢复之前的修改版本，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：\n\n$ git checkout -- test.txt\n\n再者版本库没有了，只能恢复到上一个版本了\ngit reflog 版本记录，然后 git reset --hard 版本ID\n\n\n\n## 远程仓库\n使用gitHub,要创建ssh key 公钥，并上传公钥到github\n本地库和远程库进行关联\ngit remote add origin git@github.com:dht5867/learngit.git\n\norigin 远程库的名称，一般这样命名\n\n将本地库内容提交到远程库，实际上是把当前分支master推送到远程。\n\ngit push -u origin master\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n\n\n远程仓库克隆 \ngit clone  git@github.com:dht5867/gitskills.git\n\n## 分支管理\n\n\n通过改变head 指针的指向改变当前工作版本\n\n\ngit branch dev 创建分支dev\n\ngit checkout dev 转到dev分支\n\ngit checkout -b dev 合并为一句\n\ngit branch 查看所有分支，命令会列出所有分支，当前分支前面会标一个*号。\n\n合并分支到当前分支\n\ngit merge dev ,合并分支到当前master分支，直接把master指向指向dev,fast-forward,快速合并\n\n删除分支  git branch -d dev\n\n当Git merge  合并分支有冲突时，需要手动解决冲突，在次add commit\n\ngit log --graph 查看分支变化图\n\n分支管理策略\n\ngit merge --no-ff -m \"禁用fast-forword,合并分支\" dev\n\nMerge made by the 'recursive' strategy.\n\nmaster分支中，保留足够稳定的代码，即已经发布或者即将发布的代码； \ndevelop分支，用于后续开发，一旦通过稳定性测试，就合并到master分支中；\n在develop分支的基础上，产生各个模块分支，模块功能实现之后，合并到develop分支上，\n测试稳定之后，再合并到master分支中。\n\nbug分支\n就是针对bug修复创建一个分支，又不影响当前的工作，修复完成合并，在将修复临时分支删除。\n\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。\n\n\n强制性删除分支 git branch -D feature-vulcan\n\n## 多人协作\n\n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，\n并且，远程仓库的默认名称是origin。\n\ngit remote -v 显示远程库信息\n\norigin\tgit@github.com:dht5867/gitskills.git (fetch) 抓取\norigin\tgit@github.com:dht5867/gitskills.git (push) 推送\n\n推送分支\n\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\nmaster分支是主分支，因此要时刻与远程同步；\n\ndev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\nbug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\nfeature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n\n如果远程有文件先，git pull origin master抓取下\n\n在进行git push origin master 推送\n\n抓取分支\n\n多人协作\n\n \n当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。\n\n要查看远程库的信息，用git remote：\n\n$ git remote\norigin\n或者，用git remote -v显示更详细的信息：\n\n$ git remote -v\norigin  git@github.com:michaelliao/learngit.git (fetch)\norigin  git@github.com:michaelliao/learngit.git (push)\n上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。\n\n推送分支\n\n推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：\n\n$ git push origin master\n如果要推送其他分支，比如dev，就改成：\n\n$ git push origin dev\n但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？\n\nmaster分支是主分支，因此要时刻与远程同步；\n\ndev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；\n\nbug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；\n\nfeature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。\n\n总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！\n\n\n抓取分支\n\n多人协作时，大家都会往master和dev分支上推送各自的修改。\n\n现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：\n\n 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：\n\n$ git checkout -b dev origin/dev\n现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：\n\n \n你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：\n\n```\n$ git add hello.py \n$ git commit -m \"add coding: utf-8\"\n[dev bd6ae48] add coding: utf-8\n 1 file changed, 1 insertion(+)\n$ git push origin dev\nTo git@github.com:michaelliao/learngit.git\n ! [rejected]        dev -> dev (non-fast-forward)\nerror: failed to push some refs to 'git@github.com:michaelliao/learngit.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Merge the remote changes (e.g. 'git pull')\nhint: before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：\n\n```\n$ git pull\nremote: Counting objects: 5, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom github.com:michaelliao/learngit\n   fc38031..291bea8  dev        -> origin/dev\nThere is no tracking information for the current branch.\nPlease specify which branch you want to merge with.\nSee git-pull(1) for details\n\n    git pull <remote> <branch>\n\nIf you wish to set tracking information for this branch you can do so with:\n\n    git branch --set-upstream dev origin/<branch>\n```\ngit pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：\n\n```\n$ git branch --set-upstream dev origin/dev\nBranch dev set up to track remote branch dev from origin.\n再pull：\n\n$ git pull\n\n\nAuto-merging hello.py\nCONFLICT (content): Merge conflict in hello.py\nAutomatic merge failed; fix conflicts and then commit the result.\n这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：\n\n```\n```\n$ git commit -m \"merge & fix hello.py\"\n[dev adca45d] merge & fix hello.py\n$ git push origin dev\nCounting objects: 10, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (5/5), done.\nWriting objects: 100% (6/6), 747 bytes, done.\nTotal 6 (delta 0), reused 0 (delta 0)\nTo git@github.com:michaelliao/learngit.git\n   291bea8..adca45d  dev -> dev\n\n```\n因此，多人协作的工作模式通常是这样：\n\n首先，可以试图用git push origin branch-name推送自己的修改；\n\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\n\n如果合并有冲突，则解决冲突，并在本地提交；\n\n没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！\n\n如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。\n\n这就是多人协作的工作模式，一旦熟悉了，就非常简单。\n\n\n查看远程库信息，使用git remote -v；\n\n本地新建的分支如果不推送到远程，对其他人就是不可见的；\n\n从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；\n\n在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；\n\n建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；\n\n从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。\n\n\n参考链接\nhttps://www.liaoxuefeng.com/wiki/896043488029600","tags":["-git"]},{"title":"springboot中文乱码问题","url":"/2019/07/02/springboot中文乱码问题/","content":"# springboot中文乱码问题\n## 统一utf-8编码\n```\nspring.http.encoding.force=true\nspring.http.encoding.charset=UTF-8\nspring.http.encoding.enabled=true\n```\n## 自定义web配置转码\n\n```\n @Bean\n    public HttpMessageConverter<String> responseBodyConverter(){\n        StringHttpMessageConverter converter = new StringHttpMessageConverter(Charset.forName(\"UTF-8\"));\n        return converter;\n    }\n\n\n    @Bean\n    public ObjectMapper getObjectMapper() {\n        return new ObjectMapper();\n    }\n\n\n    @Bean\n    public MappingJackson2HttpMessageConverter messageConverter() {\n        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n        converter.setObjectMapper(getObjectMapper());\n        return converter;\n    }\n\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        \n        //解决中文乱码\n        converters.add(responseBodyConverter());\n        //解决 添加解决中文乱码后 上述配置之后，返回json数据直接报错 500：no convertter for return value of type\n        converters.add(messageConverter());\n        super.configureMessageConverters(converters);\n    }\n```\n## 设置Tomcat编码\n```\n   // factory.setUriEncoding(Charset.forName(\"UTF-8\"));\n      factory.setUriEncoding(Charset.defaultCharset());\n```\n## 设置rest编码\n```\n     // MediaType type = MediaType.parseMediaType(\"application/x-www-form-urlencoded; charset=UTF-8\");\n        //headers.setContentType(type);\n        //headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED) ;\n```\n## jar 运行时设置编码\n```\n java -Dfile.encoding=UTF-8  -jar\n```","tags":["-中文乱码"]},{"title":"springboot项目混淆方案","url":"/2019/07/02/springboot项目混淆方案/","content":"\n# springboot 项目混淆\n\nproguard简单来说是为了防止反编译，更准确的说，进行业务代码的混淆，是使得代码易读性变差。\n\n## 引入proguard-maven-plugin\n\n```\n<plugin>\n        <groupId>com.github.wvengen</groupId>\n        <artifactId>proguard-maven-plugin</artifactId>\n        <version>2.0.14</version>\n        <executions>\n          <execution>\n            <phase>package</phase>\n            <goals>\n              <goal>proguard</goal>\n            </goals>\n          </execution>\n        </executions>\n        <configuration>\n          <proguardVersion>6.0.3</proguardVersion>\n          <injar>${project.build.finalName}.jar</injar>\n          <!-- <injar>classes</injar> -->\n          <outjar>${project.build.finalName}.jar</outjar>\n          <!--\n                    <outjar>${project.build.finalName}.jar</outjar>\n          -->\n          <obfuscate>true</obfuscate>\n          <options>\n            <!--# JDK目标版本1.8-->\n            <option>-target 1.8</option>\n            <!-- 不做收缩（删除注释、未被引用代码）-->\n            <option>-dontshrink</option>\n            <!-- 不做优化（变更代码实现逻辑）-->\n            <option>-dontoptimize</option>\n            <!--  ##对于类成员的命名的混淆采取唯一策略-->\n            <option>-useuniqueclassmembernames</option>\n            <!--## 混淆类名之后，对使用Class.forName('className')之类的地方进行相应替代-->\n            <option>-adaptclassstrings</option>\n            <!--混淆时不生成大小写混合的类名，默认是可以大小写混合-->\n            <option>-dontusemixedcaseclassnames</option>\n            <!--忽略警告-->\n            <option>-ignorewarnings</option>\n            <!-- This option will replace all strings in reflections method invocations with new class names.\n                 For example, invokes Class.forName('className')-->\n            <!-- <option>-adaptclassstrings</option> -->\n            <!-- This option will save all original annotations and etc. Otherwise all we be removed from files.-->\n            <!-- 不混淆所有特殊的类-->\n            <option>-keepattributes Exceptions,InnerClasses,Signature,Deprecated,\n              SourceFile,LineNumberTable,*Annotation*,EnclosingMethod\n            </option>\n            <!-- This option will save all original names in interfaces (without obfuscate).-->\n            <!--\n                         <option>-keepnames interface **</option>\n            -->\n            <!-- This option will save all original methods parameters in files defined in -keep sections,\n                 otherwise all parameter names will be obfuscate.-->\n\n            <!--保留参数名字-->\n            <option>-keepparameternames</option>\n            <!--保留主程序入口-->\n            <!--\n                        <option>-keep @org.springframework.boot.autoconfigure.SpringBootApplication class * {*;}</option>\n            -->\n            <!-- <option>-libraryjars **</option> -->\n            <!-- This option will save all original class files (without obfuscate) but obfuscate all in domain package.-->\n            <!--<option>-keep class !com.slm.proguard.example.spring.boot.domain.** { *; }</option>-->\n\n<!--\n            <option>-keep class !com.bmsoft.graph.** { *; }</option>\n-->\n            <option>-keep class com.bmsoft.graph.config.** { *; }</option>\n            <option>-keep class com.bmsoft.graph.LinkGraphApplication { *; }</option>\n            <option>-keep class com.bmsoft.graph.mapper.** { *; }</option>\n<!--\n            <option>-keep class com.bmsoft.graph.auth.filter.** { *; }</option>\n-->\n            <option>-keep class com.bmsoft.graph.aspect.** { *; }</option>\n            <option>-keep class com.bmsoft.graph.domain.** { *; }</option>\n            <option>-keep class com.bmsoft.graph.controller.** { *; }</option>\n<!--\n            <option>-keep interface * extends * { *; }</option>\n-->\n             <!--##保留枚举成员及方法-->\n            <option> -keepclassmembers enum * { *; }</option>\n            <option>-keepclassmembers class * {\n              <!-- @org.springframework.beans.factory.annotation.Autowired *; -->\n              @org.springframework.beans.factory.annotation.Autowired *;\n              @org.springframework.beans.factory.annotation.Value *;\n              }\n            </option>\n          </options>\n          <libs>\n            <!-- Include main JAVA library required.-->\n            <lib>${java.home}/lib/rt.jar</lib>\n            <lib>${java.home}/lib/jce.jar</lib>\n            <!-- <lib>${java.home}/lib/spring-boot-starter-web-1.4.1.RELEASE.jar</lib> -->\n          </libs>\n        </configuration>\n        <dependencies>\n          <dependency>\n            <groupId>net.sf.proguard</groupId>\n            <artifactId>proguard-base</artifactId>\n            <version>6.0.3</version>\n          </dependency>\n        </dependencies>\n      </plugin>\n```\n\n这里引用了com.github.wvengen的proguard-maven-plugin插件，使用的proguard-base版本是6.0.3\n这里使用java8，因为libs那里照常配置rt.jar，jce.jar，如果是java9的话，则需要换成相应的模块。\n\n另外指定proguard的阶段为package，springboot打包在repackage阶段\n\n```\n<plugin>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-maven-plugin</artifactId>\n        <executions>\n          <execution>\n            <!-- <phase>none</phase> -->\n            <goals>\n              <goal>repackage</goal>\n            </goals>\n            <configuration>\n              <mainClass>com.bmsoft.graph.LinkGraphApplication</mainClass>\n            </configuration>\n          </execution>\n        </executions>\n      </plugin>\n```\n\n## bean命名重复异常\n\n由于proguard混淆貌似不能指定混淆的类名在basePackages下面类名混淆后唯一，不同包名经常有a.class，b.class,c.class之类重复的类名，因此spring容器初始化bean的时候会报错。\n\n异常信息如下\n```\norg.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [com.example.demo.MvcDemoApplication]; nested exception is org.springframework.context.annotation.ConflictingBeanDefinitionException: Annotation-specified bean name 'a' for bean class [com.example.demo.c.a] conflicts with existing, non-compatible bean definition of same name and class [com.example.demo.b.a]\n    at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:181) ~[spring-context-4.3.10.RELEASE.jar!/:4.3.10.RELEASE]\n```\n\n需要在\b更改bean 命名\b\b\n```\npublic class LinkGraphApplication {\n\n  public static class CustomGenerator implements BeanNameGenerator {\n\n    @Override\n    public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) {\n      return definition.getBeanClassName();\n    }\n  }\n\n  public static void main(String[] args) {\n    new SpringApplicationBuilder(LinkGraphApplication.class)\n        .beanNameGenerator(new CustomGenerator())\n        .run(args);\n  }\n}\n```\n\n## 执行maven命令,打成jar包\n\n```\nclean package -DskipTests\n```\n\n## 运行jar包\n\nnohup java -jar  jar包名.jar -&\n \n### 可能出现的问题\n\b项目中引入了swagger 插件，需要在打包的时候，不进行bean的初始化配置\n\n```\n@Configuration\n@ConditionalOnProperty(prefix = \"swagger\", value = {\"enable\"}, havingValue = \"true\")\n@EnableSwagger2\npublic class SwaggerConfig {\n   @Bean\n  public Docket createRestApi() {\n    ParameterBuilder tokenParam = new ParameterBuilder();\n    List<Parameter> params = new ArrayList<Parameter>();\n    tokenParam.name(\"Authorization\").description(\"令牌标识\").modelRef(new ModelRef(\"string\"))\n        .parameterType(\"header\").required(false).defaultValue(TOKEN).build();\n    params.add(tokenParam.build());\n    return new Docket(DocumentationType.SWAGGER_2)\n        .select()\n        .apis(RequestHandlerSelectors.basePackage(\"com.bmsoft.graph.controller\"))\n        .paths(PathSelectors.any())\n        .build()\n        .globalOperationParameters(params)\n        .apiInfo(apiInfo())\n        .pathMapping(\"\");\n        .new ResponseMessageBuilder().code(403).message(\"Forbidden!!\").build()));\n  }\n\n\n  private ApiInfo apiInfo() {\n    return new ApiInfoBuilder()\n        .title(\"图服务的 API\")\n        .description(\"图服务\")\n        .contact(\"图服务\")\n        .version(\"1.0.0\")\n        .build();\n  }\n}\n```\n\n## 反编译\n\nWindows下，直接解压jar 包，可以查看jar包\b内的文件形式，Mac 可以使用 unarchiver 进行解压jar包，要查看字节码文件的话，可以\b直接把class文件放到idea进行查看\n\n## 注意\n\n-keep class 类/包.**  表示保留类名\n\n-keepclassmembers class 类/包.**{ *;} 表示保留类下边的所有变量，均不混淆\n\n\n参考链接 \nhttps://blog.csdn.net/songluyi/article/details/79554928\n\nhttps://www.jianshu.com/p/8f6c72def69d","tags":["springboot混淆"]},{"title":"学习使我快乐","url":"/2019/06/25/学习使我快乐/","content":"## 知足\n怎么去拥有 一道彩虹</br> \n怎么去拥抱 一夏天的风</br>\n天上的星星 笑地上的人</br>\n总是不能懂 不能觉得足够</br>\n如果我爱上 你的笑容</br>\n要怎么收藏 要怎么拥有</br>\n如果你快乐 不是为我</br>\n会不会放手 其实才是拥有</br>\n当一阵风吹来 风筝飞上天空</br>\n为了你而祈祷 而祝福 而感动</br>\n终于你身影消失在 人海尽头</br>\n才发现 笑着哭 最痛</br>\n那天你和我 那个山丘</br>\n那样的唱着 那一年的歌</br>\n那样的回忆 那么足够</br>\n足够我天天 都品尝着寂寞</br>\n当一阵风吹来 风筝飞上天空</br>\n为了你而祈祷 而祝福 而感动</br>\n终于你身影消失在 人海尽头</br>\n才发现 笑着哭 最痛</br>\n当一阵风吹来 风筝飞上天空</br>\n为了你而祈祷 而祝福 而感动</br>\n终于你身影消失在 人海尽头</br>\n才发现 笑着哭 最痛</br>\n哦……</br>\n如果我爱上 你的笑容</br>\n要怎么收藏 要怎么拥有</br>\n如果你快乐 再不是为我</br>\n会不会放手 其实才是拥有</br>\n知足的快乐</br>\n叫我忍受心痛</br>\n知足的快乐</br>\n叫我忍受心痛</br>","tags":["-五月天"]}]